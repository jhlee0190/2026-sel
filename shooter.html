<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1" />
  <title>ì„¤ë‚  ë¯¸ë‹ˆê²Œì„: ë§Œë‘ë„ë‘‘ í‡´ì¹˜</title>
  <style>
    :root { color-scheme: light; }
    body{ margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; background:#fff7df; }
    header{ padding:14px 16px; text-align:center; background:#b30000; color:#fff; }
    header .sub{ opacity:.9; font-size:13px; margin-top:6px; }
    .wrap{ max-width:900px; margin:0 auto; padding:12px; }
    .panel{
      display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:space-between;
      background:#fff; border-radius:14px; padding:10px 12px; box-shadow:0 6px 18px rgba(0,0,0,.08);
      margin:12px 0;
    }
    .panel .left{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .badge{ background:#ffe6e6; color:#b30000; padding:6px 10px; border-radius:999px; font-weight:700; font-size:13px; }
    .btn{
      border:0; border-radius:12px; padding:10px 12px; font-weight:800; cursor:pointer;
      background:#ff6666; color:#fff; box-shadow:0 6px 14px rgba(255,102,102,.25);
    }
    .btn:active{ transform:translateY(1px); }
    .btn.secondary{ background:#2b6cb0; box-shadow:0 6px 14px rgba(43,108,176,.2); }
    canvas{
      width:100%; height:auto; background:#ffffff; border-radius:18px;
      box-shadow:0 10px 30px rgba(0,0,0,.10);
      touch-action:none;
    }
    .help{ font-size:13px; opacity:.85; line-height:1.5; }
    .help kbd{ background:#f3f3f3; border:1px solid #ddd; padding:2px 6px; border-radius:6px; font-weight:700; }
    footer{ text-align:center; padding:14px 0 18px; opacity:.7; font-size:12px; }
  </style>
</head>
<body>
  <header>
    <div style="font-size:20px;font-weight:900;">ğŸ ì„¤ë‚  ë¯¸ë‹ˆê²Œì„: ë§Œë‘ë„ë‘‘ í‡´ì¹˜ ğŸ¥ŸğŸ’¦</div>
    <div class="sub">ë¬¼ì´(ë ˆì´ì €)ë¡œ ë‹¤ê°€ì˜¤ëŠ” ë§Œë‘ë„ë‘‘ì„ ë§‰ì•„ë³´ì! (ê°€ì¡±ìš© Â· ì”í˜¹í‘œí˜„ ì—†ìŒ)</div>
  </header>

  <div class="wrap">
    <div class="panel">
      <div class="left">
        <span class="badge">ì ìˆ˜: <span id="score">0</span></span>
        <span class="badge">ëª©ìˆ¨: <span id="life">3</span></span>
        <span class="badge">ë ˆë²¨: <span id="level">1</span></span>
        <span class="badge">ìµœê³ ì ìˆ˜: <span id="best">0</span></span>
      </div>
      <div class="right">
        <button class="btn" id="startBtn">ì‹œì‘ / ì¬ì‹œì‘</button>
        <button class="btn secondary" id="pauseBtn">ì¼ì‹œì •ì§€</button>
      </div>
    </div>

    <canvas id="game" width="900" height="520"></canvas>

    <div class="panel">
      <div class="help">
        ì¡°ì‘:
        PCëŠ” <kbd>â†</kbd><kbd>â†’</kbd> ì´ë™, <kbd>Space</kbd> ë°œì‚¬, <kbd>P</kbd> ì¼ì‹œì •ì§€<br/>
        ëª¨ë°”ì¼ì€ í™”ë©´ ë“œë˜ê·¸ë¡œ ì´ë™ + í™”ë©´ íƒ­í•˜ë©´ ë°œì‚¬
      </div>
    </div>

    <footer>Â© 2026 family mini game â€” GitHub Pagesì— ì˜¬ë¦¬ë©´ QRë¡œ ë°”ë¡œ ì ‘ì† ê°€ëŠ¥</footer>
  </div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  const scoreEl = document.getElementById('score');
  const lifeEl  = document.getElementById('life');
  const levelEl = document.getElementById('level');
  const bestEl  = document.getElementById('best');

  const startBtn = document.getElementById('startBtn');
  const pauseBtn = document.getElementById('pauseBtn');

  let running = false;
  let paused = false;
  let score = 0;
  let life = 3;
  let level = 1;

  const bestKey = 'seollal_shooter_best';
  let best = Number(localStorage.getItem(bestKey) || 0);
  bestEl.textContent = best;

  const player = {
    x: canvas.width/2,
    y: canvas.height - 60,
    r: 18,
    speed: 520,
    cooldown: 0,
  };

  const bullets = [];
  const enemies = [];
  let spawnTimer = 0;

  function reset() {
    score = 0; life = 3; level = 1;
    bullets.length = 0;
    enemies.length = 0;
    player.x = canvas.width/2;
    player.cooldown = 0;
    spawnTimer = 0;
    running = true;
    paused = false;
    syncHUD();
  }

  function syncHUD() {
    scoreEl.textContent = score;
    lifeEl.textContent = life;
    levelEl.textContent = level;
    bestEl.textContent = best;
  }

  function updateLevel() {
    const newLevel = 1 + Math.floor(score / 15);
    if (newLevel !== level) {
      level = newLevel;
      levelEl.textContent = level;
    }
  }

  function spawnEnemy() {
    const r = 16 + Math.random()*10;
    const x = r + Math.random() * (canvas.width - 2*r);
    const y = -r - 10;
    const baseSpeed = 70 + Math.random()*40;
    const speed = baseSpeed + (level-1)*18;
    enemies.push({ x, y, r, speed });
  }

  function shoot() {
    if (!running || paused) return;
    if (player.cooldown > 0) return;

    bullets.push({
      x: player.x,
      y: player.y - player.r - 6,
      r: 6,
      vy: -520
    });
    player.cooldown = Math.max(0.12, 0.22 - (level-1)*0.01);
  }

  function dist2(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return dx*dx+dy*dy; }
  function collide(a,b){ const rr = (a.r+b.r); return dist2(a,b) <= rr*rr; }

  const keys = new Set();
  window.addEventListener('keydown', (e) => {
    if (e.code === 'Space') { e.preventDefault(); shoot(); }
    if (e.key.toLowerCase() === 'p') togglePause();
    keys.add(e.code);
  });
  window.addEventListener('keyup', (e) => keys.delete(e.code));

  let pointerDown = false;
  let pointerId = null;
  canvas.addEventListener('pointerdown', (e) => {
    canvas.setPointerCapture(e.pointerId);
    pointerDown = true; pointerId = e.pointerId;
    moveByPointer(e);
    shoot();
  });
  canvas.addEventListener('pointermove', (e) => {
    if (!pointerDown || e.pointerId !== pointerId) return;
    moveByPointer(e);
  });
  canvas.addEventListener('pointerup', (e) => {
    if (e.pointerId === pointerId) { pointerDown = false; pointerId = null; }
  });

  function moveByPointer(e){
    const rect = canvas.getBoundingClientRect();
    const px = (e.clientX - rect.left) * (canvas.width / rect.width);
    player.x = Math.max(player.r, Math.min(canvas.width - player.r, px));
  }

  startBtn.addEventListener('click', reset);
  pauseBtn.addEventListener('click', togglePause);
  function togglePause(){
    if (!running) return;
    paused = !paused;
    pauseBtn.textContent = paused ? 'ì¬ê°œ' : 'ì¼ì‹œì •ì§€';
  }

  let last = performance.now();
  function loop(now){
    requestAnimationFrame(loop);
    const dt = Math.min(0.033, (now-last)/1000);
    last = now;
    if (!running || paused) { render(); return; }

    let dir = 0;
    if (keys.has('ArrowLeft') || keys.has('KeyA')) dir -= 1;
    if (keys.has('ArrowRight') || keys.has('KeyD')) dir += 1;
    player.x += dir * player.speed * dt;
    player.x = Math.max(player.r, Math.min(canvas.width - player.r, player.x));

    player.cooldown = Math.max(0, player.cooldown - dt);

    const spawnInterval = Math.max(0.35, 1.05 - (level-1)*0.08);
    spawnTimer += dt;
    while (spawnTimer >= spawnInterval) {
      spawnTimer -= spawnInterval;
      spawnEnemy();
    }

    for (let i=bullets.length-1;i>=0;i--){
      bullets[i].y += bullets[i].vy * dt;
      if (bullets[i].y < -20) bullets.splice(i,1);
    }

    for (let i=enemies.length-1;i>=0;i--){
      enemies[i].y += enemies[i].speed * dt;
      if (enemies[i].y > canvas.height + 40){
        enemies.splice(i,1);
        life -= 1;
        if (life <= 0){
          gameOver();
          return;
        }
        syncHUD();
      }
    }

    for (let ei=enemies.length-1; ei>=0; ei--){
      const e = enemies[ei];
      for (let bi=bullets.length-1; bi>=0; bi--){
        const b = bullets[bi];
        if (collide(e,b)){
          enemies.splice(ei,1);
          bullets.splice(bi,1);
          score += 1;
          if (score > best){
            best = score;
            localStorage.setItem(bestKey, String(best));
          }
          updateLevel();
          syncHUD();
          break;
        }
      }
    }

    render();
  }

  function gameOver(){
    running = false;
    paused = false;
    pauseBtn.textContent = 'ì¼ì‹œì •ì§€';
    render(true);
  }

  function render(over=false){
    ctx.clearRect(0,0,canvas.width,canvas.height);

    ctx.fillStyle = '#fff3cc';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = '#ffe6e6';
    ctx.fillRect(0,0,canvas.width,60);

    ctx.fillStyle = '#b30000';
    ctx.font = 'bold 18px system-ui';
    ctx.fillText('ğŸ¥Ÿ ë§Œë‘ë„ë‘‘ì„ ë§‰ì•„ë¼! (ë¬¼ì´ ğŸ’¦)', 14, 38);

    ctx.beginPath();
    ctx.fillStyle = '#2b6cb0';
    ctx.arc(player.x, player.y, player.r, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 14px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('ğŸ’¦', player.x, player.y+5);
    ctx.textAlign = 'start';

    for (const b of bullets){
      ctx.beginPath();
      ctx.fillStyle = '#00a3ff';
      ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
      ctx.fill();
    }

    for (const e of enemies){
      ctx.beginPath();
      ctx.fillStyle = '#ff6666';
      ctx.arc(e.x, e.y, e.r, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 14px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText('ğŸ¥Ÿ', e.x, e.y+5);
      ctx.textAlign = 'start';
    }

    if (!running){
      overlay('ì‹œì‘ ë²„íŠ¼ì„ ëˆŒëŸ¬ ê²Œì„ ì‹œì‘!');
    } else if (paused){
      overlay('ì¼ì‹œì •ì§€ (P ë˜ëŠ” ë²„íŠ¼)');
    } else if (over){
      overlay(`ê²Œì„ ì˜¤ë²„! ì ìˆ˜ ${score}ì \nâ€œì‹œì‘/ì¬ì‹œì‘â€ìœ¼ë¡œ ë‹¤ì‹œ ë„ì „`);
    }
  }

  function overlay(text){
    ctx.save();
    ctx.fillStyle = 'rgba(0,0,0,.35)';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = '#fff';
    ctx.textAlign = 'center';
    ctx.font = 'bold 28px system-ui';
    const lines = String(text).split('\n');
    lines.forEach((ln, i) => ctx.fillText(ln, canvas.width/2, canvas.height/2 + i*36));
    ctx.restore();
  }

  render();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>

